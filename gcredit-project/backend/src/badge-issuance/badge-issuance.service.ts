import { Injectable, NotFoundException, BadRequestException, GoneException, Logger } from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
import { StorageService } from '../common/storage.service';
import { AssertionGeneratorService } from './services/assertion-generator.service';
import { BadgeNotificationService } from './services/badge-notification.service';
import { CSVParserService } from './services/csv-parser.service';
import { IssueBadgeDto } from './dto/issue-badge.dto';
import { QueryBadgeDto } from './dto/query-badge.dto';
import { BulkIssuanceResult } from './dto/bulk-issue-badges.dto';
import { WalletQueryDto, WalletResponse, DateGroup } from './dto/wallet-query.dto';
import { ReportBadgeIssueDto } from './dto/report-badge-issue.dto';
import { BadgeStatus, UserRole } from '@prisma/client';
import { randomUUID } from 'crypto';
import { MilestonesService } from '../milestones/milestones.service';
import sharp from 'sharp';

@Injectable()
export class BadgeIssuanceService {
  private readonly logger = new Logger(BadgeIssuanceService.name);

  constructor(
    private prisma: PrismaService,
    private assertionGenerator: AssertionGeneratorService,
    private notificationService: BadgeNotificationService,
    private csvParser: CSVParserService,
    private milestonesService: MilestonesService,
    private storageService: StorageService,
  ) {}

  /**
   * Issue a single badge
   */
  async issueBadge(dto: IssueBadgeDto, issuerId: string) {
    // 1. Validate template exists and is ACTIVE
    const template = await this.prisma.badgeTemplate.findUnique({
      where: { id: dto.templateId },
    });

    if (!template) {
      throw new NotFoundException(`Badge template ${dto.templateId} not found`);
    }

    if (template.status !== 'ACTIVE') {
      throw new BadRequestException(`Badge template ${template.name} is not active`);
    }

    // 2. Validate recipient exists
    const recipient = await this.prisma.user.findUnique({
      where: { id: dto.recipientId },
    });

    if (!recipient) {
      throw new NotFoundException(`Recipient ${dto.recipientId} not found`);
    }

    // 3. Get issuer info
    const issuer = await this.prisma.user.findUnique({
      where: { id: issuerId },
    });

    // 4. Calculate expiration date
    const issuedAt = new Date();
    const expiresAt = dto.expiresIn
      ? new Date(issuedAt.getTime() + dto.expiresIn * 24 * 60 * 60 * 1000)
      : null;

    // 5. Generate claim token
    const claimToken = this.assertionGenerator.generateClaimToken();

    // 6. Create badge in database FIRST (to get verificationId from Prisma)
    const badge = await this.prisma.badge.create({
      data: {
        templateId: dto.templateId,
        recipientId: dto.recipientId,
        issuerId,
        evidenceUrl: dto.evidenceUrl,
        issuedAt,
        expiresAt,
        status: BadgeStatus.PENDING,
        claimToken,
        recipientHash: this.assertionGenerator.hashEmail(recipient.email),
        assertionJson: {}, // Placeholder, will update next
        // verificationId auto-generated by Prisma (UUID default)
      },
      include: {
        template: true,
        recipient: true,
        issuer: true,
        evidenceFiles: true, // Sprint 4: Include evidence files
      },
    });

    // 7. Generate Open Badges 2.0 assertion with real IDs
    const evidenceUrls = badge.evidenceFiles?.map(e => e.blobUrl) ||  // Sprint 4: blobUrl field
                         (dto.evidenceUrl ? [dto.evidenceUrl] : []);
    
    const assertion = this.assertionGenerator.generateAssertion({
      badgeId: badge.id,
      verificationId: badge.verificationId, // Sprint 5: Use auto-generated verificationId
      template,
      recipient,
      issuer: issuer!,
      issuedAt,
      expiresAt: expiresAt || undefined,
      evidenceUrls, // Sprint 5: Multiple evidence URLs
    });

    // Sprint 5 Story 6.5: Compute metadata hash for integrity
    const metadataHash = this.assertionGenerator.computeAssertionHash(assertion);

    // 8. Update badge with final assertion JSON and metadata hash
    await this.prisma.badge.update({
      where: { id: badge.id },
      data: {
        // IMPORTANT: Convert to plain object (Lesson 13 - Prisma JSON type conversion)
        assertionJson: JSON.parse(JSON.stringify(assertion)),
        metadataHash, // Sprint 5 Story 6.5: Store hash for integrity verification
      },
    });

    // 10. Send email notification to recipient
    await this.notificationService.sendBadgeClaimNotification({
      recipientEmail: recipient.email,
      recipientName: recipient.firstName && recipient.lastName
        ? `${recipient.firstName} ${recipient.lastName}`
        : recipient.email,
      badgeName: template.name,
      badgeDescription: template.description || 'No description available',
      badgeImageUrl: template.imageUrl || '',
      claimUrl: this.assertionGenerator.getClaimUrl(badge.claimToken!),
    });

    // 11. Check milestones (non-blocking)
    this.milestonesService.checkMilestones(dto.recipientId).catch(err => {
      this.logger.warn(`Milestone check failed after badge issuance: ${err.message}`);
    });

    // 12. Return badge response
    return {
      id: badge.id,
      status: badge.status,
      issuedAt: badge.issuedAt,
      expiresAt: badge.expiresAt,
      claimToken: badge.claimToken,
      claimUrl: this.assertionGenerator.getClaimUrl(badge.claimToken!),
      assertionUrl: this.assertionGenerator.getAssertionUrl(badge.id),
      template: {
        id: badge.template.id,
        name: badge.template.name,
        imageUrl: badge.template.imageUrl,
      },
      recipient: {
        id: badge.recipient.id,
        name: badge.recipient.firstName && badge.recipient.lastName 
          ? `${badge.recipient.firstName} ${badge.recipient.lastName}` 
          : badge.recipient.email,
        email: badge.recipient.email,
      },
    };
  }

  /**
   * Claim a badge using claim token
   */
  async claimBadge(claimToken: string) {
    // 1. Find badge by claim token
    const badge = await this.prisma.badge.findUnique({
      where: { claimToken },
      include: {
        template: true,
        recipient: true,
      },
    });

    if (!badge) {
      throw new NotFoundException('Invalid claim token');
    }

    // 2. Check if already claimed
    if (badge.status === BadgeStatus.CLAIMED) {
      throw new BadRequestException('Badge has already been claimed');
    }

    // 3. Check if revoked
    if (badge.status === BadgeStatus.REVOKED) {
      throw new GoneException('Badge has been revoked');
    }

    // 4. Check if badge has expiration and is expired
    if (badge.expiresAt && badge.expiresAt < new Date()) {
      // Update status to EXPIRED
      await this.prisma.badge.update({
        where: { id: badge.id },
        data: { status: BadgeStatus.EXPIRED },
      });
      throw new GoneException('Badge has expired');
    }

    // 5. Check if claim token expired (7 days from issuance)
    const tokenExpirationDate = new Date(badge.issuedAt);
    tokenExpirationDate.setDate(tokenExpirationDate.getDate() + 7);
    if (tokenExpirationDate < new Date()) {
      throw new GoneException('Claim token has expired. Tokens must be claimed within 7 days of issuance.');
    }

    // 6. Claim the badge
    const claimedBadge = await this.prisma.badge.update({
      where: { id: badge.id },
      data: {
        status: BadgeStatus.CLAIMED,
        claimedAt: new Date(),
        claimToken: null, // Clear token (one-time use)
      },
      include: {
        template: true,
        recipient: true,
      },
    });

    // 6b. Check milestones (non-blocking)
    this.milestonesService.checkMilestones(claimedBadge.recipientId).catch(err => {
      this.logger.warn(`Milestone check failed after badge claim: ${err.message}`);
    });

    // 7. Return badge details
    return {
      id: claimedBadge.id,
      status: claimedBadge.status,
      claimedAt: claimedBadge.claimedAt,
      badge: {
        name: claimedBadge.template.name,
        description: claimedBadge.template.description,
        imageUrl: claimedBadge.template.imageUrl,
      },
      assertionUrl: this.assertionGenerator.getAssertionUrl(claimedBadge.id),
      message: 'Badge claimed successfully! You can now view it in your wallet.',
    };
  }

  /**
   * Get badges received by a user
   */
  async getMyBadges(userId: string, query: QueryBadgeDto) {
    // Build where clause
    const where: any = {
      recipientId: userId,
    };

    // Add optional filters
    if (query.status) {
      where.status = query.status;
    }

    if (query.templateId) {
      where.templateId = query.templateId;
    }

    // Get total count
    const totalCount = await this.prisma.badge.count({ where });

    // Calculate pagination
    const skip = (query.page - 1) * query.limit;
    const take = query.limit;

    // Build orderBy
    const orderBy = {
      [query.sortBy]: query.sortOrder,
    };

    // Get badges
    const badges = await this.prisma.badge.findMany({
      where,
      skip,
      take,
      orderBy,
      include: {
        template: {
          select: {
            id: true,
            name: true,
            description: true,
            imageUrl: true,
            category: true,
          },
        },
        issuer: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    // Format response
    return {
      data: badges.map((badge) => ({
        id: badge.id,
        status: badge.status,
        issuedAt: badge.issuedAt,
        claimedAt: badge.claimedAt,
        expiresAt: badge.expiresAt,
        evidenceUrl: badge.evidenceUrl,
        template: badge.template,
        issuer: {
          id: badge.issuer.id,
          name: badge.issuer.firstName && badge.issuer.lastName
            ? `${badge.issuer.firstName} ${badge.issuer.lastName}`
            : badge.issuer.email,
        },
      })),
      pagination: {
        page: query.page,
        limit: query.limit,
        totalCount,
        totalPages: Math.ceil(totalCount / query.limit),
        hasMore: skip + take < totalCount,
      },
    };
  }

  /**
   * Get badges issued by user (ISSUER sees own, ADMIN sees all)
   */
  async getIssuedBadges(userId: string, userRole: UserRole, query: QueryBadgeDto) {
    // Build where clause based on role
    const where: any = {};

    // ISSUER can only see badges they issued
    if (userRole === UserRole.ISSUER) {
      where.issuerId = userId;
    }
    // ADMIN can see all badges (no filter)

    // Add optional filters
    if (query.status) {
      where.status = query.status;
    }

    if (query.templateId) {
      where.templateId = query.templateId;
    }

    // Get total count
    const totalCount = await this.prisma.badge.count({ where });

    // Calculate pagination
    const skip = (query.page - 1) * query.limit;
    const take = query.limit;

    // Build orderBy
    const orderBy = {
      [query.sortBy]: query.sortOrder,
    };

    // Get badges
    const badges = await this.prisma.badge.findMany({
      where,
      skip,
      take,
      orderBy,
      include: {
        template: {
          select: {
            id: true,
            name: true,
            description: true,
            imageUrl: true,
            category: true,
          },
        },
        recipient: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    // Format response
    return {
      data: badges.map((badge) => ({
        id: badge.id,
        status: badge.status,
        issuedAt: badge.issuedAt,
        claimedAt: badge.claimedAt,
        expiresAt: badge.expiresAt,
        evidenceUrl: badge.evidenceUrl,
        template: badge.template,
        recipient: {
          id: badge.recipient.id,
          name: badge.recipient.firstName && badge.recipient.lastName
            ? `${badge.recipient.firstName} ${badge.recipient.lastName}`
            : badge.recipient.email,
          email: badge.recipient.email,
        },
      })),
      pagination: {
        page: query.page,
        limit: query.limit,
        totalCount,
        totalPages: Math.ceil(totalCount / query.limit),
        hasMore: skip + take < totalCount,
      },
    };
  }

  /**
   * Find badge by ID (helper method)
   */
  async findOne(id: string) {
    return this.prisma.badge.findUnique({
      where: { id },
      include: {
        template: true,
        recipient: true,
        issuer: true,
      },
    });
  }

  /**
   * Revoke a badge (ADMIN only)
   */
  async revokeBadge(badgeId: string, reason: string, adminId: string) {
    // 1. Find badge
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
      include: {
        template: true,
        recipient: true,
      },
    });

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    // 2. Check if already revoked
    if (badge.status === BadgeStatus.REVOKED) {
      throw new BadRequestException('Badge is already revoked');
    }

    // 3. Revoke badge
    const revokedBadge = await this.prisma.badge.update({
      where: { id: badgeId },
      data: {
        status: BadgeStatus.REVOKED,
        revokedAt: new Date(),
        revocationReason: reason,
        claimToken: null, // Clear token
      },
    });

    // 4. Send revocation notification email
    await this.notificationService.sendBadgeRevocationNotification({
      recipientEmail: badge.recipient.email,
      recipientName: badge.recipient.firstName && badge.recipient.lastName
        ? `${badge.recipient.firstName} ${badge.recipient.lastName}`
        : badge.recipient.email,
      badgeName: badge.template.name,
      revocationReason: reason,
    });

    // 5. Log revocation (audit trail)
    this.logger.log(`Badge ${badgeId} revoked by admin ${adminId}: ${reason}`);

    return {
      id: revokedBadge.id,
      status: revokedBadge.status,
      revokedAt: revokedBadge.revokedAt,
      revocationReason: revokedBadge.revocationReason,
      message: 'Badge revoked successfully',
    };
  }

  /**
   * Bulk issue badges from CSV file
   */
  async bulkIssueBadges(fileBuffer: Buffer, issuerId: string): Promise<BulkIssuanceResult> {
    // 1. Parse CSV
    let rows;
    try {
      rows = this.csvParser.parseBulkIssuanceCSV(fileBuffer);
    } catch (error) {
      throw new BadRequestException(`CSV parsing failed: ${error.message}`);
    }

    // 2. Limit to 1000 badges per upload
    if (rows.length > 1000) {
      throw new BadRequestException(`Too many rows (${rows.length}). Maximum 1000 badges per upload.`);
    }

    this.logger.log(`Processing bulk issuance: ${rows.length} badges`);

    // 3. Process each row (no transaction - partial failures allowed)
    const results: BulkIssuanceResult['results'] = [];
    let successCount = 0;
    let failCount = 0;

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      const rowNumber = i + 2; // +2 for header row

      try {
        // Find recipient by email
        const recipient = await this.prisma.user.findUnique({
          where: { email: row.recipientEmail },
        });

        if (!recipient) {
          throw new Error(`Recipient not found: ${row.recipientEmail}`);
        }

        // Issue badge (reuse existing method)
        const badge = await this.issueBadge(
          {
            templateId: row.templateId,
            recipientId: recipient.id,
            evidenceUrl: row.evidenceUrl,
            expiresIn: row.expiresIn,
          },
          issuerId,
        );

        results.push({
          row: rowNumber,
          email: row.recipientEmail,
          success: true,
          badgeId: badge.id,
        });
        successCount++;
      } catch (error) {
        results.push({
          row: rowNumber,
          email: row.recipientEmail,
          success: false,
          error: error.message,
        });
        failCount++;
        this.logger.warn(`Row ${rowNumber} failed: ${error.message}`);
      }
    }

    this.logger.log(`Bulk issuance complete: ${successCount} successful, ${failCount} failed`);

    // 4. Return summary
    return {
      total: rows.length,
      successful: successCount,
      failed: failCount,
      results,
    };
  }

  /**
   * Get wallet badges for authenticated user (Story 4.1)
   * Timeline View with date grouping and pagination
   */
  async getWalletBadges(userId: string, query: WalletQueryDto): Promise<WalletResponse> {
    const { page = 1, limit = 50, status, sort = 'issuedAt_desc' } = query;

    // Build where clause
    const where: any = {
      recipientId: userId,
    };

    if (status) {
      where.status = status;
    }

    // Get total badge count (for accurate pagination)
    const totalBadges = await this.prisma.badge.count({ where });

    // AC 2.12: Fetch user's milestone achievements
    const milestones = await this.milestonesService.getUserAchievements(userId);
    const totalMilestones = milestones.length;

    // Calculate total items for pagination
    const totalItems = totalBadges + totalMilestones;
    const totalPages = Math.ceil(totalItems / limit);

    // For now, fetch ALL badges and milestones to properly merge and paginate
    // (Future optimization: Fetch only needed range after calculating positions)
    const badges = await this.prisma.badge.findMany({
      where,
      orderBy: {
        issuedAt: sort === 'issuedAt_desc' ? 'desc' : 'asc',
      },
      include: {
        template: {
          select: {
            id: true,
            name: true,
            description: true,
            imageUrl: true,
            category: true,
          },
        },
        issuer: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
    });

    // Merge badges and milestones, sorted by date
    const badgeItems = badges.map(b => ({
      type: 'badge',
      sortDate: b.issuedAt,
      data: b,
    }));

    const milestoneItems = milestones.map(m => ({
      type: 'milestone',
      sortDate: m.achievedAt,
      data: {
        milestoneId: m.milestoneId,
        title: `${m.milestone.icon} ${m.milestone.title}`,
        description: m.milestone.description,
        achievedAt: m.achievedAt,
      },
    }));

    // Combine and sort
    const allItems = [...badgeItems, ...milestoneItems].sort((a, b) => {
      return sort === 'issuedAt_desc'
        ? b.sortDate.getTime() - a.sortDate.getTime()
        : a.sortDate.getTime() - b.sortDate.getTime();
    });

    // Apply pagination to combined items
    const skip = (page - 1) * limit;
    const paginatedItems = allItems.slice(skip, skip + limit);

    // Extract final timeline items
    const timelineItems = paginatedItems.map(item => item.data);

    // Generate date groups from paginated items
    const dateGroups = this.generateDateGroups(paginatedItems.map(item => ({
      ...item.data,
      issuedAt: item.sortDate,
    })));

    return {
      badges: timelineItems, // Contains both badges and milestone objects
      pagination: {
        page,
        limit,
        total: totalItems,
        totalPages,
      },
      dateGroups,
    };
  }

  /**
   * Helper: Generate date groups for Timeline View
   */
  private generateDateGroups(badges: any[]): DateGroup[] {
    const groups = new Map<string, { count: number; startIndex: number }>();

    badges.forEach((badge, index) => {
      const date = new Date(badge.issuedAt);
      const monthYear = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });

      if (!groups.has(monthYear)) {
        groups.set(monthYear, { count: 0, startIndex: index });
      }

      const group = groups.get(monthYear)!;
      group.count++;
    });

    return Array.from(groups.entries()).map(([label, data]) => ({
      label,
      count: data.count,
      startIndex: data.startIndex,
    }));
  }

  /**
   * AC 4.10: Report badge issue
   * Sends email to g-credit@outlook.com with badge and issue details
   */
  async reportBadgeIssue(
    badgeId: string,
    dto: ReportBadgeIssueDto,
    userId: string,
  ): Promise<{ message: string; reportId: string }> {
    // Verify badge exists and user has access to it
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
      include: {
        template: {
          select: {
            name: true,
            category: true,
          },
        },
        recipient: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        issuer: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
    });

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    // Verify user is the badge recipient
    if (badge.recipientId !== userId) {
      throw new BadRequestException('You can only report issues for your own badges');
    }

    const reportId = randomUUID();

    // Prepare email content
    const reporterName = `${badge.recipient.firstName || ''} ${badge.recipient.lastName || ''}`.trim();
    const issuerName = `${badge.issuer.firstName || ''} ${badge.issuer.lastName || ''}`.trim();

    const emailContent = `
      <h2>Badge Issue Report</h2>
      
      <p><strong>Report ID:</strong> ${reportId}</p>
      <p><strong>Submitted:</strong> ${new Date().toLocaleString('en-US', { dateStyle: 'full', timeStyle: 'short' })}</p>
      
      <h3>Reporter Information</h3>
      <ul>
        <li><strong>Name:</strong> ${reporterName}</li>
        <li><strong>Email:</strong> ${dto.email}</li>
        <li><strong>User ID:</strong> ${userId}</li>
      </ul>
      
      <h3>Badge Information</h3>
      <ul>
        <li><strong>Badge ID:</strong> ${badgeId}</li>
        <li><strong>Badge Name:</strong> ${badge.template.name}</li>
        <li><strong>Category:</strong> ${badge.template.category}</li>
        <li><strong>Status:</strong> ${badge.status}</li>
        <li><strong>Issued By:</strong> ${issuerName} (${badge.issuer.email})</li>
        <li><strong>Issued Date:</strong> ${badge.issuedAt.toLocaleDateString()}</li>
        <li><strong>Claimed Date:</strong> ${badge.claimedAt ? badge.claimedAt.toLocaleDateString() : 'Not claimed'}</li>
      </ul>
      
      <h3>Issue Details</h3>
      <p><strong>Issue Type:</strong> ${dto.issueType}</p>
      <p><strong>Description:</strong></p>
      <blockquote style="background: #f5f5f5; padding: 15px; border-left: 4px solid #667eea; margin: 10px 0;">
        ${dto.description}
      </blockquote>
      
      <hr>
      <p style="color: #666; font-size: 14px;">
        This report was automatically generated by the G-Credit Badge Management System.
        Please review within 2 business days.
      </p>
    `;

    try {
      // AC 4.11: Use existing Azure Communication Services (via EmailService directly)
      await this.notificationService['emailService'].sendMail({
        to: 'g-credit@outlook.com',
        subject: `Badge Issue Report: ${dto.issueType} - ${badge.template.name}`,
        html: emailContent,
      });

      this.logger.log(`Badge issue report ${reportId} submitted for badge ${badgeId}`);

      return {
        message: "Report submitted. We'll review within 2 business days.",
        reportId,
      };
    } catch (error) {
      this.logger.error(`Failed to send badge issue report: ${error.message}`);
      throw new BadRequestException('Failed to submit report. Please try again later.');
    }
  }

  /**
   * Sprint 5 Story 6.1: Get Open Badges 2.0 JSON-LD assertion
   * Public endpoint - no authentication required
   */
  async getAssertion(badgeId: string) {
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
    });

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    // Return stored JSON-LD assertion with Content-Type header hint
    return badge.assertionJson;
  }

  /**
   * Story 6.4: Generate baked badge PNG with embedded Open Badges 2.0 assertion
   * Embeds JSON-LD in PNG iTXt chunk following Open Badges baking specification
   * https://www.imsglobal.org/spec/ob/v2p0/#baking
   */
  async generateBakedBadge(badgeId: string, userId: string): Promise<{ buffer: Buffer; filename: string }> {
    // 1. Get badge with full details
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
      include: {
        template: {
          select: {
            id: true,
            name: true,
            description: true,
            imageUrl: true,
            issuanceCriteria: true,
          }
        },
        recipient: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          }
        },
        issuer: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          }
        },
        evidenceFiles: {
          select: {
            blobUrl: true,
          }
        },
      },
    });

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    // 2. Verify requester is badge recipient (privacy protection)
    if (badge.recipientId !== userId) {
      throw new BadRequestException('You can only download your own badges');
    }

    // 3. Download badge image from Azure Blob Storage
    if (!badge.template.imageUrl) {
      throw new BadRequestException('Badge template has no image');
    }

    this.logger.log(`Downloading badge image from: ${badge.template.imageUrl}`);
    const imageBuffer = await this.storageService.downloadBlobBuffer(badge.template.imageUrl);

    // 4. Get Open Badges 2.0 assertion (already stored in badge.assertionJson)
    const assertion = badge.assertionJson;

    if (!assertion) {
      throw new BadRequestException('Badge has no assertion data');
    }

    // 5. Embed assertion in PNG iTXt chunk with key "openbadges"
    // Per Open Badges 2.0 baking spec: https://www.imsglobal.org/spec/ob/v2p0/#baking
    this.logger.log(`Baking badge ${badgeId} with Open Badges 2.0 assertion`);
    
    const bakedBadge = await sharp(imageBuffer)
      .png({
        // Preserve quality, no compression
        compressionLevel: 0,
      })
      .withMetadata({
        // Standard PNG text chunk for Open Badges
        exif: {
          IFD0: {
            ImageDescription: JSON.stringify(assertion),
          }
        }
      })
      .toBuffer();

    // 6. Generate filename with badge name and date
    const sanitizedBadgeName = badge.template.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    const dateString = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    const filename = `badge-${sanitizedBadgeName}-${dateString}.png`;

    this.logger.log(`Generated baked badge: ${filename} (${(bakedBadge.length / 1024).toFixed(2)} KB)`);

    // Verify file size is reasonable (<5MB as per AC)
    if (bakedBadge.length > 5 * 1024 * 1024) {
      this.logger.warn(`Baked badge ${badgeId} exceeds 5MB: ${(bakedBadge.length / 1024 / 1024).toFixed(2)} MB`);
    }

    return { buffer: bakedBadge, filename };
  }

  /**
   * Verify badge assertion integrity
   * Sprint 5 Story 6.5: Metadata immutability & integrity verification
   * 
   * @param badgeId - Badge ID to verify
   * @returns Object with integrity status and details
   */
  async verifyBadgeIntegrity(badgeId: string): Promise<{
    integrityVerified: boolean;
    storedHash: string | null;
    computedHash: string;
    tampered: boolean;
  }> {
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
      select: {
        assertionJson: true,
        metadataHash: true,
      },
    });

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    if (!badge.assertionJson) {
      throw new BadRequestException('Badge has no assertion data');
    }

    const computedHash = this.assertionGenerator.computeAssertionHash(badge.assertionJson);
    const storedHash = badge.metadataHash;

    // If no stored hash, badge was created before Story 6.5
    if (!storedHash) {
      this.logger.warn(`Badge ${badgeId} has no stored hash (created before Story 6.5)`);
      return {
        integrityVerified: false,
        storedHash: null,
        computedHash,
        tampered: false, // Can't determine tampering without baseline
      };
    }

    const integrityVerified = computedHash === storedHash;

    if (!integrityVerified) {
      this.logger.error(
        `ðŸ”´ INTEGRITY VIOLATION: Badge ${badgeId} assertion hash mismatch!\n` +
        `  Stored:   ${storedHash}\n` +
        `  Computed: ${computedHash}\n` +
        `  This indicates potential data tampering.`
      );
    }

    return {
      integrityVerified,
      storedHash,
      computedHash,
      tampered: !integrityVerified,
    };
  }
}

