import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ForbiddenException,
  GoneException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../common/prisma.service';
import { StorageService } from '../common/storage.service';
import { createPaginatedResponse } from '../common/utils/pagination.util';
import { AssertionGeneratorService } from './services/assertion-generator.service';
import { BadgeNotificationService } from './services/badge-notification.service';
import { CSVParserService } from './services/csv-parser.service';
import { TeamsBadgeNotificationService } from '../microsoft-graph/teams/teams-badge-notification.service';
import { GraphEmailService } from '../microsoft-graph/services/graph-email.service';
import { ConfigService } from '@nestjs/config';
import { IssueBadgeDto } from './dto/issue-badge.dto';
import { QueryBadgeDto } from './dto/query-badge.dto';
import { BulkIssuanceResult } from './dto/bulk-issue-badges.dto';
import {
  WalletQueryDto,
  WalletResponse,
  DateGroup,
} from './dto/wallet-query.dto';
import { ReportBadgeIssueDto } from './dto/report-badge-issue.dto';
import { BadgeStatus, Prisma, UserRole, BadgeVisibility } from '@prisma/client';
import { randomUUID } from 'crypto';
import { MilestonesService } from '../milestones/milestones.service';
import sharp from 'sharp';

@Injectable()
export class BadgeIssuanceService {
  private readonly logger = new Logger(BadgeIssuanceService.name);

  constructor(
    private prisma: PrismaService,
    private assertionGenerator: AssertionGeneratorService,
    private notificationService: BadgeNotificationService,
    private csvParser: CSVParserService,
    private milestonesService: MilestonesService,
    private storageService: StorageService,
    private teamsNotificationService: TeamsBadgeNotificationService,
    private graphEmailService: GraphEmailService,
    private configService: ConfigService,
  ) {}

  /**
   * Get list of active users available as badge recipients
   */
  async getRecipients() {
    return this.prisma.user.findMany({
      where: { isActive: true },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        department: true,
      },
      orderBy: { lastName: 'asc' },
    });
  }

  /**
   * Issue a single badge
   */
  async issueBadge(dto: IssueBadgeDto, issuerId: string) {
    // 1. Validate template exists and is ACTIVE
    const template = await this.prisma.badgeTemplate.findUnique({
      where: { id: dto.templateId },
    });

    if (!template) {
      throw new NotFoundException(`Badge template ${dto.templateId} not found`);
    }

    if (template.status !== 'ACTIVE') {
      throw new BadRequestException(
        `Badge template ${template.name} is not active`,
      );
    }

    // 2. Validate recipient exists
    const recipient = await this.prisma.user.findUnique({
      where: { id: dto.recipientId },
    });

    if (!recipient) {
      throw new NotFoundException(`Recipient ${dto.recipientId} not found`);
    }

    // 3. Get issuer info
    const issuer = await this.prisma.user.findUnique({
      where: { id: issuerId },
    });

    // 4. Calculate expiration date
    const issuedAt = new Date();
    const expiresAt = dto.expiresIn
      ? new Date(issuedAt.getTime() + dto.expiresIn * 24 * 60 * 60 * 1000)
      : null;

    // 5. Generate claim token
    const claimToken = this.assertionGenerator.generateClaimToken();

    // 6-8. Atomic transaction: create badge + generate assertion + update badge
    // (ARCH-C6: Each badge issued in atomic transaction for data integrity)
    const badge = await this.prisma.$transaction(async (tx) => {
      // 6. Create badge in database FIRST (to get verificationId from Prisma)
      const created = await tx.badge.create({
        data: {
          templateId: dto.templateId,
          recipientId: dto.recipientId,
          issuerId,
          evidenceUrl: dto.evidenceUrl,
          issuedAt,
          expiresAt,
          status: BadgeStatus.PENDING,
          claimToken,
          recipientHash: this.assertionGenerator.hashEmail(recipient.email),
          assertionJson: {}, // Placeholder, will update next
          // verificationId auto-generated by Prisma (UUID default)
        },
        include: {
          template: true,
          recipient: true,
          issuer: true,
          evidenceFiles: true, // Sprint 4: Include evidence files
        },
      });

      // 7. Generate Open Badges 2.0 assertion with real IDs
      const evidenceUrls =
        created.evidenceFiles?.map((e) => e.blobUrl) || // Sprint 4: blobUrl field
        (dto.evidenceUrl ? [dto.evidenceUrl] : []);

      const assertion = this.assertionGenerator.generateAssertion({
        badgeId: created.id,
        verificationId: created.verificationId, // Sprint 5: Use auto-generated verificationId
        template,
        recipient,
        issuer: issuer!,
        issuedAt,
        expiresAt: expiresAt || undefined,
        evidenceUrls, // Sprint 5: Multiple evidence URLs
      });

      // Sprint 5 Story 6.5: Compute metadata hash for integrity
      const metadataHash =
        this.assertionGenerator.computeAssertionHash(assertion);

      // 8. Update badge with final assertion JSON and metadata hash
      const updated = await tx.badge.update({
        where: { id: created.id },
        data: {
          // IMPORTANT: Convert to plain object (Lesson 13 - Prisma JSON type conversion)
          assertionJson: JSON.parse(
            JSON.stringify(assertion),
          ) as Prisma.InputJsonValue,
          metadataHash, // Sprint 5 Story 6.5: Store hash for integrity verification
        },
        include: {
          template: true,
          recipient: true,
          issuer: true,
          evidenceFiles: true,
        },
      });

      // 9. Create audit log entry for badge issuance
      await tx.auditLog.create({
        data: {
          entityType: 'Badge',
          entityId: created.id,
          action: 'ISSUED',
          actorId: issuerId,
          actorEmail: issuer?.email ?? 'unknown',
          timestamp: issuedAt,
          metadata: {
            badgeName: template.name,
            recipientEmail: recipient.email,
            templateId: template.id,
          },
        },
      });

      return updated;
    });

    // 10. Send email notification via Teams notification service (uses Graph Email)
    // Story 7.4: Unified notification through TeamsNotificationService
    // Story 8.4: Await email to surface errors in bulk completion summary
    let emailError: string | undefined;
    try {
      await this.teamsNotificationService.sendBadgeIssuanceNotification(
        badge.id,
        recipient.id,
      );
    } catch (err: unknown) {
      const message = (err as Error).message;
      emailError = message;
      this.logger.warn(
        `Email notification failed for badge ${badge.id}: ${message}`,
      );
    }

    // 11. Check milestones (awaited â€” include results in response)
    const newMilestones = await this.milestonesService
      .checkMilestones(dto.recipientId)
      .catch((err: Error) => {
        this.logger.warn(
          `Milestone check failed after badge issuance: ${err.message}`,
        );
        return [];
      });

    // 12. Return badge response
    return {
      id: badge.id,
      status: badge.status,
      issuedAt: badge.issuedAt,
      expiresAt: badge.expiresAt,
      claimToken: badge.claimToken,
      claimUrl: this.assertionGenerator.getClaimUrl(badge.claimToken!),
      assertionUrl: this.assertionGenerator.getAssertionUrl(badge.id),
      emailError, // Story 8.4 AC6: Surface email failures in completion summary
      newMilestones, // Story 12.4: Newly achieved milestones
      template: {
        id: badge.template.id,
        name: badge.template.name,
        imageUrl: badge.template.imageUrl,
      },
      recipient: {
        id: badge.recipient.id,
        name:
          badge.recipient.firstName && badge.recipient.lastName
            ? `${badge.recipient.firstName} ${badge.recipient.lastName}`
            : badge.recipient.email,
        email: badge.recipient.email,
      },
    };
  }

  /**
   * Claim a badge using claim token
   */
  /**
   * Claim a badge by ID â€” authenticated user must be the recipient
   */
  async claimBadgeById(badgeId: string, userId?: string) {
    if (!userId) {
      throw new BadRequestException(
        'Authentication required to claim badge by ID',
      );
    }

    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
      include: { template: true, recipient: true },
    });

    if (!badge) {
      throw new NotFoundException('Badge not found');
    }

    if (badge.recipientId !== userId) {
      throw new BadRequestException(
        'You can only claim badges assigned to you',
      );
    }

    return this.processClaimBadge(badge);
  }

  async claimBadge(claimToken: string, userId?: string) {
    // 1. Find badge by claim token
    const badge = await this.prisma.badge.findUnique({
      where: { claimToken },
      include: {
        template: true,
        recipient: true,
      },
    });

    if (!badge) {
      throw new NotFoundException(
        'This claim link is invalid or has already been used. ' +
          'If you have already claimed this badge, you can find it in your wallet.',
      );
    }

    // 1b. Verify authenticated user is the badge recipient
    if (userId && badge.recipientId !== userId) {
      throw new ForbiddenException(
        'This badge was issued to a different user. ' +
          'Please log in with the correct account to claim this badge.',
      );
    }

    return this.processClaimBadge(badge);
  }

  /**
   * Shared claim logic for both token-based and ID-based claiming
   */
  private async processClaimBadge(badge: {
    id: string;
    status: string;
    expiresAt: Date | null;
    issuedAt: Date;
    recipientId: string;
    template: {
      name: string;
      description: string | null;
      imageUrl: string | null;
    };
    recipient: { id: string; email: string };
  }) {
    if (!badge) {
      throw new NotFoundException(
        'This claim link is invalid or has already been used. ' +
          'If you have already claimed this badge, you can find it in your wallet.',
      );
    }

    // 2. Check if already claimed
    if (badge.status === BadgeStatus.CLAIMED) {
      throw new BadRequestException('Badge has already been claimed');
    }

    // 3. Check if revoked
    if (badge.status === BadgeStatus.REVOKED) {
      throw new GoneException('Badge has been revoked');
    }

    // 4. Check if badge has expiration and is expired
    if (badge.expiresAt && badge.expiresAt < new Date()) {
      // Update status to EXPIRED
      await this.prisma.badge.update({
        where: { id: badge.id },
        data: { status: BadgeStatus.EXPIRED },
      });
      throw new GoneException('Badge has expired');
    }

    // 5. Check if claim token expired (7 days from issuance)
    const tokenExpirationDate = new Date(badge.issuedAt);
    tokenExpirationDate.setDate(tokenExpirationDate.getDate() + 7);
    if (tokenExpirationDate < new Date()) {
      throw new GoneException(
        'Claim token has expired. Tokens must be claimed within 7 days of issuance.',
      );
    }

    // 6. Claim the badge
    const claimedBadge = await this.prisma.badge.update({
      where: { id: badge.id },
      data: {
        status: BadgeStatus.CLAIMED,
        claimedAt: new Date(),
        // Keep claimToken so re-visits give accurate status messages
        // (e.g. "already claimed" vs "revoked") instead of generic "invalid token"
      },
      include: {
        template: true,
        recipient: true,
      },
    });

    // 6b. Check milestones (awaited â€” include results in response)
    const newMilestones = await this.milestonesService
      .checkMilestones(claimedBadge.recipientId)
      .catch((err: Error) => {
        this.logger.warn(
          `Milestone check failed after badge claim: ${err.message}`,
        );
        return [];
      });

    // 7. Return badge details
    return {
      id: claimedBadge.id,
      status: claimedBadge.status,
      claimedAt: claimedBadge.claimedAt,
      badge: {
        name: claimedBadge.template.name,
        description: claimedBadge.template.description,
        imageUrl: claimedBadge.template.imageUrl,
      },
      assertionUrl: this.assertionGenerator.getAssertionUrl(claimedBadge.id),
      newMilestones, // Story 12.4: Newly achieved milestones
      message:
        'Badge claimed successfully! You can now view it in your wallet.',
    };
  }

  /**
   * Revoke a badge (Sprint 7 - Story 9.1)
   * Only ADMIN or the original ISSUER can revoke badges
   */
  async revokeBadge(
    badgeId: string,
    dto: { reason: string; notes?: string; actorId: string },
  ) {
    const { reason, notes, actorId } = dto;

    // Step 1: Fetch badge and actor
    const [badge, actor] = await Promise.all([
      this.prisma.badge.findUnique({
        where: { id: badgeId },
        include: { template: true, recipient: true },
      }),
      this.prisma.user.findUnique({ where: { id: actorId } }),
    ]);

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    if (!actor) {
      throw new NotFoundException(`User ${actorId} not found`);
    }

    // Step 2: Authorization check (must happen before idempotency to prevent info leak)
    let canRevoke =
      actor.role === UserRole.ADMIN ||
      (actor.role === UserRole.ISSUER && badge.issuerId === actorId);

    // Story 12.3a: MANAGER can revoke badges for their direct reports (managerId-based)
    if (actor.role === UserRole.MANAGER) {
      canRevoke = badge.recipient?.managerId === actor.id;
    }

    if (!canRevoke) {
      throw new ForbiddenException(
        `User ${actorId} (${actor.role}) cannot revoke badge ${badgeId}`,
      );
    }

    // Step 3: Check if already revoked (idempotency)
    if (badge.status === BadgeStatus.REVOKED) {
      this.logger.warn(`Badge ${badgeId} already revoked, skipping`);
      return { ...badge, alreadyRevoked: true };
    }

    // Step 4: Update badge (transaction for safety)
    const updatedBadge = await this.prisma.$transaction(async (tx) => {
      // 4a: Update badge
      const updated = await tx.badge.update({
        where: { id: badgeId },
        data: {
          status: BadgeStatus.REVOKED,
          revokedAt: new Date(),
          revokedBy: actorId,
          revocationReason: reason,
          revocationNotes: notes,
        },
        include: {
          template: true,
          recipient: true,
        },
      });

      // 4b: Create audit log entry
      await tx.auditLog.create({
        data: {
          entityType: 'Badge',
          entityId: badgeId,
          action: 'REVOKED',
          actorId: actorId,
          actorEmail: actor.email,
          timestamp: new Date(),
          metadata: {
            reason,
            notes,
            badgeName: badge.template.name,
            recipientEmail: badge.recipient.email,
          },
        },
      });

      return updated;
    });

    this.logger.log(
      `Badge ${badgeId} revoked by ${actor.email} (reason: ${reason})`,
    );

    // Story 9.4: Send revocation email notification asynchronously
    // Email failure should NOT block revocation operation
    // HIGH #2: Implements 3 retry attempts per AC3
    // HIGH #3: Creates audit log for notification result per AC3
    // HIGH #4: Manager CC prepared for future use (requires User.managerId field)
    this.notificationService
      .sendBadgeRevocationNotification({
        recipientEmail: badge.recipient.email,
        recipientName:
          `${badge.recipient.firstName} ${badge.recipient.lastName}`.trim() ||
          badge.recipient.email,
        badgeName: badge.template.name,
        revocationReason: reason,
        revocationDate: updatedBadge.revokedAt || new Date(),
        revocationNotes: notes,
        walletUrl: `${this.configService.get('PLATFORM_URL', 'http://localhost:5173')}/wallet`,
        // managerEmail: Future - requires User.managerId relationship in schema
      })
      .then(async (result) => {
        // HIGH #3: Create audit log entry for notification result
        try {
          await this.prisma.auditLog.create({
            data: {
              entityType: 'BadgeNotification',
              entityId: badgeId,
              action: result.success
                ? 'NOTIFICATION_SENT'
                : 'NOTIFICATION_FAILED',
              actorId: actorId,
              actorEmail: actor.email,
              timestamp: new Date(),
              metadata: {
                notificationType: 'REVOCATION',
                recipientEmail: badge.recipient.email,
                success: result.success,
                attempts: result.attempts,
                error: result.error || null,
              },
            },
          });
        } catch (auditErr) {
          this.logger.error(
            `Failed to create notification audit log:`,
            (auditErr as Error).message,
          );
        }
      })
      .catch((err: Error) => {
        this.logger.error(
          `Failed to send revocation notification to ${badge.recipient.email}:`,
          err.message,
        );
        // Do not throw - email failure should not fail revocation
      });

    return updatedBadge;
  }

  /**
   * Get badges received by a user
   * Story 8.2: Enhanced search/filter support
   */
  async getMyBadges(userId: string, query: QueryBadgeDto) {
    // Build where clause
    const where: Prisma.BadgeWhereInput = {
      recipientId: userId,
    };

    // Add optional filters
    if (query.status) {
      where.status = query.status;
    }

    if (query.templateId) {
      where.templateId = query.templateId;
    }

    // Story 8.2: Add search filter (template name or issuer name)
    if (query.search) {
      const searchTerm = query.search.trim();
      where.OR = [
        { template: { name: { contains: searchTerm, mode: 'insensitive' } } },
        {
          issuer: { firstName: { contains: searchTerm, mode: 'insensitive' } },
        },
        { issuer: { lastName: { contains: searchTerm, mode: 'insensitive' } } },
        { issuer: { email: { contains: searchTerm, mode: 'insensitive' } } },
      ];
    }

    // Story 8.2: Filter by skills (template.skillIds contains any of the requested skills)
    if (query.skills && query.skills.length > 0) {
      where.template = {
        ...(where.template as Prisma.BadgeTemplateWhereInput),
        skillIds: {
          hasSome: query.skills,
        },
      } as typeof where.template;
    }

    // Story 8.2: Filter by date range
    if (query.fromDate) {
      where.issuedAt = {
        ...(where.issuedAt as Prisma.DateTimeFilter | undefined),
        gte: new Date(query.fromDate),
      };
    }
    if (query.toDate) {
      where.issuedAt = {
        ...(where.issuedAt as Prisma.DateTimeFilter | undefined),
        lte: new Date(query.toDate),
      };
    }

    // Story 8.2: Filter by issuer
    if (query.issuerId) {
      where.issuerId = query.issuerId;
    }

    // Get total count
    const totalCount = await this.prisma.badge.count({ where });

    // Calculate pagination
    const skip = (query.page - 1) * query.limit;
    const take = query.limit;

    // Build orderBy
    const orderBy = {
      [query.sortBy]: query.sortOrder,
    };

    // Get badges
    const badges = await this.prisma.badge.findMany({
      where,
      skip,
      take,
      orderBy,
      include: {
        template: {
          select: {
            id: true,
            name: true,
            description: true,
            imageUrl: true,
            category: true,
            // Story 8.2: skillIds is a direct field on template
            skillIds: true,
          },
        },
        issuer: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    // Format response
    return createPaginatedResponse(
      badges.map((badge) => ({
        id: badge.id,
        status: badge.status,
        visibility: badge.visibility,
        issuedAt: badge.issuedAt,
        claimedAt: badge.claimedAt,
        expiresAt: badge.expiresAt,
        evidenceUrl: badge.evidenceUrl,
        // Story 8.2: Template includes skillIds directly
        template: badge.template,
        issuer: {
          id: badge.issuer.id,
          name:
            badge.issuer.firstName && badge.issuer.lastName
              ? `${badge.issuer.firstName} ${badge.issuer.lastName}`
              : badge.issuer.email,
        },
      })),
      totalCount,
      query.page,
      query.limit,
    );
  }

  /**
   * Get badges issued by user (ISSUER sees own, ADMIN sees all)
   * Story 9.5 AC5: Supports search and filter
   * Story 8.2: Enhanced with skills, dates, issuer filters
   */
  async getIssuedBadges(
    userId: string,
    userRole: UserRole,
    query: QueryBadgeDto,
  ) {
    // Build where clause based on role
    const where: Prisma.BadgeWhereInput = {};

    // ISSUER can only see badges they issued
    if (userRole === UserRole.ISSUER) {
      where.issuerId = userId;
    }
    // Story 12.3a: MANAGER can only see badges for their direct reports (managerId-based)
    else if (userRole === UserRole.MANAGER) {
      where.recipient = { managerId: userId };
    }
    // ADMIN can see all badges (no filter) - but Story 8.2 allows issuer filter
    else if (query.issuerId) {
      where.issuerId = query.issuerId;
    }

    // Add optional filters
    if (query.status) {
      where.status = query.status;
    } else if (query.activeOnly) {
      // Story 9.5 AC5: Filter for active badges (PENDING or CLAIMED)
      where.status = { in: [BadgeStatus.PENDING, BadgeStatus.CLAIMED] };
    }

    // Story 8.2: Filter by skills (template.skillIds contains any of the requested skills)
    if (query.skills && query.skills.length > 0) {
      where.template = {
        ...(where.template as Prisma.BadgeTemplateWhereInput),
        skillIds: {
          hasSome: query.skills,
        },
      } as typeof where.template;
    }

    // Story 8.2: Filter by date range
    if (query.fromDate) {
      where.issuedAt = {
        ...(where.issuedAt as Prisma.DateTimeFilter | undefined),
        gte: new Date(query.fromDate),
      };
    }
    if (query.toDate) {
      where.issuedAt = {
        ...(where.issuedAt as Prisma.DateTimeFilter | undefined),
        lte: new Date(query.toDate),
      };
    }

    if (query.templateId) {
      where.templateId = query.templateId;
    }

    // Story 9.5 AC5: Add search filter
    if (query.search) {
      const searchTerm = query.search.trim();
      where.OR = [
        { recipient: { email: { contains: searchTerm, mode: 'insensitive' } } },
        {
          recipient: {
            firstName: { contains: searchTerm, mode: 'insensitive' },
          },
        },
        {
          recipient: {
            lastName: { contains: searchTerm, mode: 'insensitive' },
          },
        },
        { template: { name: { contains: searchTerm, mode: 'insensitive' } } },
      ];
    }

    // Get total count
    const totalCount = await this.prisma.badge.count({ where });

    // Calculate pagination
    const skip = (query.page - 1) * query.limit;
    const take = query.limit;

    // Build orderBy
    const orderBy = {
      [query.sortBy]: query.sortOrder,
    };

    // Get badges with all fields needed for Admin UI (Story 9.5)
    const badges = await this.prisma.badge.findMany({
      where,
      skip,
      take,
      orderBy,
      include: {
        template: {
          select: {
            id: true,
            name: true,
            description: true,
            imageUrl: true,
            category: true,
            // Story 8.2: skillIds is a direct field
            skillIds: true,
          },
        },
        recipient: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        issuer: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        revoker: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    // Format response - include all fields for Admin UI (Story 9.5)
    return createPaginatedResponse(
      badges.map((badge) => ({
        id: badge.id,
        templateId: badge.templateId,
        recipientId: badge.recipientId,
        issuerId: badge.issuerId,
        status: badge.status,
        issuedAt: badge.issuedAt,
        claimedAt: badge.claimedAt,
        expiresAt: badge.expiresAt,
        revokedAt: badge.revokedAt,
        revocationReason: badge.revocationReason,
        revocationNotes: badge.revocationNotes,
        revokedBy: badge.revokedBy,
        evidenceUrl: badge.evidenceUrl,
        // Story 8.2: Template includes skillIds directly
        template: badge.template,
        recipient: {
          id: badge.recipient.id,
          email: badge.recipient.email,
          firstName: badge.recipient.firstName,
          lastName: badge.recipient.lastName,
        },
        issuer: {
          id: badge.issuer.id,
          email: badge.issuer.email,
          firstName: badge.issuer.firstName,
          lastName: badge.issuer.lastName,
        },
        revoker: badge.revoker
          ? {
              id: badge.revoker.id,
              email: badge.revoker.email,
              firstName: badge.revoker.firstName,
              lastName: badge.revoker.lastName,
            }
          : undefined,
      })),
      totalCount,
      query.page,
      query.limit,
    );
  }

  /**
   * Find badge by ID (helper method)
   */
  /**
   * Story 11.4: Update badge visibility (PUBLIC/PRIVATE) â€” owner only
   */
  async updateVisibility(
    badgeId: string,
    visibility: BadgeVisibility,
    userId: string,
  ) {
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
    });

    if (!badge) {
      throw new NotFoundException('Badge not found');
    }

    if (badge.recipientId !== userId) {
      throw new ForbiddenException(
        'Only the badge recipient can change visibility',
      );
    }

    return this.prisma.badge.update({
      where: { id: badgeId },
      data: { visibility },
    });
  }

  async findOne(id: string) {
    const badge = await this.prisma.badge.findUnique({
      where: { id },
      include: {
        template: true,
        recipient: true,
        issuer: true,
        // Story 9.3: Include revoker for badge details
        revoker: true,
      },
    });

    if (!badge) {
      return null;
    }

    // Story 9.3: Transform response to include/exclude revocation fields
    // Compute effective status: EXPIRED if expiresAt is in the past
    const isExpired =
      badge.expiresAt &&
      badge.expiresAt < new Date() &&
      badge.status !== BadgeStatus.REVOKED;
    const effectiveStatus = isExpired ? 'EXPIRED' : badge.status;

    const response: Record<string, unknown> = {
      ...badge,
      status: effectiveStatus,
    };

    // Story 9.3 AC2: Add categorized revocation details
    if (badge.status === BadgeStatus.REVOKED) {
      const publicReasons = ['Expired', 'Issued in Error'];
      response.isPublicReason = badge.revocationReason
        ? publicReasons.includes(badge.revocationReason)
        : false;

      if (badge.revoker) {
        response.revokedBy = {
          name: `${badge.revoker.firstName} ${badge.revoker.lastName}`,
          role: badge.revoker.role,
        };
      } else {
        // Story 11.24 AC-M8: Fallback when revoker (admin) has been deleted
        response.revokedBy = { name: 'Unknown User', email: '', role: 'N/A' };
      }
    }

    return response;
  }

  /**
   * Revoke a badge (ADMIN only)
   */
  /**
   * Bulk issue badges from CSV file
   */
  async bulkIssueBadges(
    fileBuffer: Buffer,
    issuerId: string,
  ): Promise<BulkIssuanceResult> {
    // 1. Parse CSV
    let rows;
    try {
      rows = this.csvParser.parseBulkIssuanceCSV(fileBuffer);
    } catch (error) {
      throw new BadRequestException(
        `CSV parsing failed: ${(error as Error).message}`,
      );
    }

    // 2. Limit to 1000 badges per upload
    if (rows.length > 1000) {
      throw new BadRequestException(
        `Too many rows (${rows.length}). Maximum 1000 badges per upload.`,
      );
    }

    this.logger.log(`Processing bulk issuance: ${rows.length} badges`);

    // 3. Process each row (no transaction - partial failures allowed)
    const results: BulkIssuanceResult['results'] = [];
    let successCount = 0;
    let failCount = 0;

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      const rowNumber = i + 2; // +2 for header row

      try {
        // Find recipient by email
        const recipient = await this.prisma.user.findUnique({
          where: { email: row.recipientEmail },
        });

        if (!recipient) {
          throw new Error(`Recipient not found: ${row.recipientEmail}`);
        }

        // Issue badge (reuse existing method)
        const badge = await this.issueBadge(
          {
            templateId: row.templateId,
            recipientId: recipient.id,
            evidenceUrl: row.evidenceUrl,
            expiresIn: row.expiresIn,
          },
          issuerId,
        );

        results.push({
          row: rowNumber,
          email: row.recipientEmail,
          success: true,
          badgeId: badge.id,
        });
        successCount++;
      } catch (error) {
        results.push({
          row: rowNumber,
          email: row.recipientEmail,
          success: false,
          error: (error as Error).message,
        });
        failCount++;
        this.logger.warn(
          `Row ${rowNumber} failed: ${(error as Error).message}`,
        );
      }
    }

    this.logger.log(
      `Bulk issuance complete: ${successCount} successful, ${failCount} failed`,
    );

    // 4. Return summary
    return {
      total: rows.length,
      successful: successCount,
      failed: failCount,
      results,
    };
  }

  /**
   * Get wallet badges for authenticated user (Story 4.1)
   * Timeline View with date grouping and pagination
   */
  async getWalletBadges(
    userId: string,
    query: WalletQueryDto,
  ): Promise<WalletResponse> {
    const { page = 1, limit = 50, status, sort = 'issuedAt_desc' } = query;

    // Build where clause
    const where: Prisma.BadgeWhereInput = {
      recipientId: userId,
    };

    if (status) {
      where.status = status;
    }

    // Story 8.2: Add search filter (template name or issuer name)
    if (query.search) {
      const searchTerm = query.search.trim();
      where.OR = [
        { template: { name: { contains: searchTerm, mode: 'insensitive' } } },
        {
          issuer: { firstName: { contains: searchTerm, mode: 'insensitive' } },
        },
        { issuer: { lastName: { contains: searchTerm, mode: 'insensitive' } } },
        { issuer: { email: { contains: searchTerm, mode: 'insensitive' } } },
      ];
    }

    // Story 8.2: Filter by skills (template.skillIds contains any of the requested skills)
    if (query.skills && query.skills.length > 0) {
      where.template = {
        ...(where.template as Prisma.BadgeTemplateWhereInput),
        skillIds: {
          hasSome: query.skills,
        },
      } as typeof where.template;
    }

    // Story 8.2: Filter by date range
    if (query.fromDate) {
      where.issuedAt = {
        ...(where.issuedAt as Prisma.DateTimeFilter | undefined),
        gte: new Date(query.fromDate),
      };
    }
    if (query.toDate) {
      where.issuedAt = {
        ...(where.issuedAt as Prisma.DateTimeFilter | undefined),
        lte: new Date(query.toDate),
      };
    }

    // Get total badge count (for accurate pagination)
    const totalBadges = await this.prisma.badge.count({ where });

    // AC 2.12: Fetch user's milestone achievements
    const milestones = await this.milestonesService.getUserAchievements(userId);
    const totalMilestones = milestones.length;

    // Calculate total items for pagination
    const totalItems = totalBadges + totalMilestones;

    // For now, fetch ALL badges and milestones to properly merge and paginate
    // (Future optimization: Fetch only needed range after calculating positions)
    const badges = await this.prisma.badge.findMany({
      where,
      orderBy: {
        issuedAt: sort === 'issuedAt_desc' ? 'desc' : 'asc',
      },
      include: {
        template: {
          select: {
            id: true,
            name: true,
            description: true,
            imageUrl: true,
            category: true,
            // Story 8.2: Include skillIds for filtering
            skillIds: true,
          },
        },
        issuer: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        // Story 9.3: Include revoker for REVOKED badges
        revoker: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            role: true,
          },
        },
      },
    });

    // Merge badges and milestones, sorted by date
    const badgeItems = badges.map((b) => {
      // Compute effective status: if expiresAt is in the past and badge
      // is not already REVOKED, treat it as EXPIRED for display purposes.
      const isExpired =
        b.expiresAt &&
        b.expiresAt < new Date() &&
        b.status !== BadgeStatus.REVOKED;
      const effectiveStatus = isExpired ? 'EXPIRED' : b.status;

      // Story 9.3: Transform badge to include/exclude revocation fields
      const badgeData: Record<string, unknown> = {
        id: b.id,
        recipientId: b.recipientId,
        status: effectiveStatus,
        visibility: b.visibility,
        issuedAt: b.issuedAt,
        claimedAt: b.claimedAt,
        expiresAt: b.expiresAt,
        template: b.template,
        issuer: b.issuer,
      };

      // Story 9.3 AC5: Include revocation fields only for REVOKED badges
      if (b.status === BadgeStatus.REVOKED) {
        badgeData.revokedAt = b.revokedAt;
        badgeData.revocationReason = b.revocationReason;
        badgeData.revocationNotes = b.revocationNotes;
        // Include revoker info if available
        if (b.revoker) {
          badgeData.revokedBy = {
            name: `${b.revoker.firstName} ${b.revoker.lastName}`,
            role: b.revoker.role,
          };
        }
      }

      return {
        type: 'badge',
        sortDate: b.issuedAt,
        data: badgeData,
      };
    });

    const milestoneItems = milestones.map((m) => ({
      type: 'milestone',
      sortDate: m.achievedAt,
      data: {
        milestoneId: m.milestoneId,
        title: `${m.milestone.icon} ${m.milestone.title}`,
        description: m.milestone.description,
        achievedAt: m.achievedAt,
      },
    }));

    // Combine and sort
    const allItems = [...badgeItems, ...milestoneItems].sort((a, b) => {
      return sort === 'issuedAt_desc'
        ? b.sortDate.getTime() - a.sortDate.getTime()
        : a.sortDate.getTime() - b.sortDate.getTime();
    });

    // Apply pagination to combined items
    const skip = (page - 1) * limit;
    const paginatedItems = allItems.slice(skip, skip + limit);

    // Extract final timeline items â€” preserve type field for frontend discrimination (Story 11.24 AC-C3)
    const timelineItems = paginatedItems.map((item) => ({
      ...item.data,
      type: item.type,
    }));

    // Generate date groups from paginated items
    const dateGroups = this.generateDateGroups(
      paginatedItems.map((item) => ({
        ...item.data,
        issuedAt: item.sortDate,
      })),
    );

    return {
      ...createPaginatedResponse(timelineItems, totalItems, page, limit),
      dateGroups,
    };
  }

  /**
   * Helper: Generate date groups for Timeline View
   */
  private generateDateGroups(
    badges: { issuedAt: string | number | Date }[],
  ): DateGroup[] {
    const groups = new Map<string, { count: number; startIndex: number }>();

    badges.forEach((badge, index) => {
      const date = new Date(badge.issuedAt);
      const monthYear = date.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      if (!groups.has(monthYear)) {
        groups.set(monthYear, { count: 0, startIndex: index });
      }

      const group = groups.get(monthYear)!;
      group.count++;
    });

    return Array.from(groups.entries()).map(([label, data]) => ({
      label,
      count: data.count,
      startIndex: data.startIndex,
    }));
  }

  /**
   * AC 4.10: Report badge issue
   * Sends email to g-credit@outlook.com with badge and issue details
   */
  async reportBadgeIssue(
    badgeId: string,
    dto: ReportBadgeIssueDto,
    userId: string,
  ): Promise<{ message: string; reportId: string }> {
    // Verify badge exists and user has access to it
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
      include: {
        template: {
          select: {
            name: true,
            category: true,
          },
        },
        recipient: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        issuer: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
    });

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    // Verify user is the badge recipient
    if (badge.recipientId !== userId) {
      throw new BadRequestException(
        'You can only report issues for your own badges',
      );
    }

    const reportId = randomUUID();

    // Prepare email content
    const reporterName =
      `${badge.recipient.firstName || ''} ${badge.recipient.lastName || ''}`.trim();
    const issuerName =
      `${badge.issuer.firstName || ''} ${badge.issuer.lastName || ''}`.trim();

    const emailContent = `
      <h2>Badge Issue Report</h2>
      
      <p><strong>Report ID:</strong> ${reportId}</p>
      <p><strong>Submitted:</strong> ${new Date().toLocaleString('en-US', { dateStyle: 'full', timeStyle: 'short' })}</p>
      
      <h3>Reporter Information</h3>
      <ul>
        <li><strong>Name:</strong> ${reporterName}</li>
        <li><strong>Email:</strong> ${dto.email}</li>
        <li><strong>User ID:</strong> ${userId}</li>
      </ul>
      
      <h3>Badge Information</h3>
      <ul>
        <li><strong>Badge ID:</strong> ${badgeId}</li>
        <li><strong>Badge Name:</strong> ${badge.template.name}</li>
        <li><strong>Category:</strong> ${badge.template.category}</li>
        <li><strong>Status:</strong> ${badge.status}</li>
        <li><strong>Issued By:</strong> ${issuerName} (${badge.issuer.email})</li>
        <li><strong>Issued Date:</strong> ${badge.issuedAt.toLocaleDateString()}</li>
        <li><strong>Claimed Date:</strong> ${badge.claimedAt ? badge.claimedAt.toLocaleDateString() : 'Not claimed'}</li>
      </ul>
      
      <h3>Issue Details</h3>
      <p><strong>Issue Type:</strong> ${dto.issueType}</p>
      <p><strong>Description:</strong></p>
      <blockquote style="background: #f5f5f5; padding: 15px; border-left: 4px solid #667eea; margin: 10px 0;">
        ${dto.description}
      </blockquote>
      
      <hr>
      <p style="color: #666; font-size: 14px;">
        This report was automatically generated by the G-Credit Badge Management System.
        Please review within 2 business days.
      </p>
    `;

    try {
      // AC 4.11: Send report via Microsoft Graph Email
      const fromEmail = this.configService.get<string>(
        'GRAPH_EMAIL_FROM',
        'M365DevAdmin@2wjh85.onmicrosoft.com',
      );
      await this.graphEmailService.sendEmail(
        fromEmail,
        ['g-credit@outlook.com'],
        `Badge Issue Report: ${dto.issueType} - ${badge.template.name}`,
        emailContent,
      );

      this.logger.log(
        `Badge issue report ${reportId} submitted for badge ${badgeId}`,
      );

      return {
        message: "Report submitted. We'll review within 2 business days.",
        reportId,
      };
    } catch (error) {
      this.logger.error(
        `Failed to send badge issue report: ${(error as Error).message}`,
      );
      throw new BadRequestException(
        'Failed to submit report. Please try again later.',
      );
    }
  }

  /**
   * Sprint 5 Story 6.1: Get Open Badges 2.0 JSON-LD assertion
   * Public endpoint - no authentication required
   */
  async getAssertion(badgeId: string) {
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
    });

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    // Return stored JSON-LD assertion with Content-Type header hint
    return badge.assertionJson;
  }

  /**
   * Story 6.4: Generate baked badge PNG with embedded Open Badges 2.0 assertion
   * Embeds JSON-LD in PNG iTXt chunk following Open Badges baking specification
   * https://www.imsglobal.org/spec/ob/v2p0/#baking
   */
  async generateBakedBadge(
    badgeId: string,
    userId: string,
  ): Promise<{ buffer: Buffer; filename: string }> {
    // 1. Get badge with full details
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
      include: {
        template: {
          select: {
            id: true,
            name: true,
            description: true,
            imageUrl: true,
            issuanceCriteria: true,
          },
        },
        recipient: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        issuer: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        evidenceFiles: {
          select: {
            blobUrl: true,
          },
        },
      },
    });

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    // 2. Verify requester is badge recipient (privacy protection)
    if (badge.recipientId !== userId) {
      throw new BadRequestException('You can only download your own badges');
    }

    // 3. Download badge image from Azure Blob Storage or create default
    if (!badge.template.imageUrl) {
      throw new BadRequestException('Badge template has no image');
    }

    let imageBuffer: Buffer;

    // Handle placeholder URLs for demo/testing
    if (badge.template.imageUrl.includes('placeholder.com')) {
      this.logger.log('Using placeholder - generating default badge image');

      // Create a simple 400x400 purple badge with text
      imageBuffer = await sharp({
        create: {
          width: 400,
          height: 400,
          channels: 4,
          background: { r: 79, g: 70, b: 229, alpha: 1 }, // #4F46E5
        },
      })
        .png()
        .toBuffer();
    } else {
      this.logger.log(
        `Downloading badge image from: ${badge.template.imageUrl}`,
      );
      imageBuffer = await this.storageService.downloadBlobBuffer(
        badge.template.imageUrl,
      );
    }

    // 4. Get Open Badges 2.0 assertion (already stored in badge.assertionJson)
    const assertion = badge.assertionJson;

    if (!assertion) {
      throw new BadRequestException('Badge has no assertion data');
    }

    // 5. Embed assertion in PNG iTXt chunk with key "openbadges"
    // Per Open Badges 2.0 baking spec: https://www.imsglobal.org/spec/ob/v2p0/#baking
    this.logger.log(`Baking badge ${badgeId} with Open Badges 2.0 assertion`);

    const bakedBadge = await sharp(imageBuffer)
      .png({
        // Preserve quality, no compression
        compressionLevel: 0,
      })
      .withMetadata({
        // Standard PNG text chunk for Open Badges
        exif: {
          IFD0: {
            ImageDescription: JSON.stringify(assertion),
          },
        },
      })
      .toBuffer();

    // 6. Generate filename with badge name and date
    const sanitizedBadgeName = badge.template.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    const dateString = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    const filename = `badge-${sanitizedBadgeName}-${dateString}.png`;

    this.logger.log(
      `Generated baked badge: ${filename} (${(bakedBadge.length / 1024).toFixed(2)} KB)`,
    );

    // Verify file size is reasonable (<5MB as per AC)
    if (bakedBadge.length > 5 * 1024 * 1024) {
      this.logger.warn(
        `Baked badge ${badgeId} exceeds 5MB: ${(bakedBadge.length / 1024 / 1024).toFixed(2)} MB`,
      );
    }

    return { buffer: bakedBadge, filename };
  }

  /**
   * Verify badge assertion integrity
   * Sprint 5 Story 6.5: Metadata immutability & integrity verification
   *
   * @param badgeId - Badge ID to verify
   * @returns Object with integrity status and details
   */
  async verifyBadgeIntegrity(badgeId: string): Promise<{
    integrityVerified: boolean;
    storedHash: string | null;
    computedHash: string;
    tampered: boolean;
  }> {
    const badge = await this.prisma.badge.findUnique({
      where: { id: badgeId },
      select: {
        assertionJson: true,
        metadataHash: true,
      },
    });

    if (!badge) {
      throw new NotFoundException(`Badge ${badgeId} not found`);
    }

    if (!badge.assertionJson) {
      throw new BadRequestException('Badge has no assertion data');
    }

    const computedHash = this.assertionGenerator.computeAssertionHash(
      badge.assertionJson,
    );
    const storedHash = badge.metadataHash;

    // If no stored hash, badge was created before Story 6.5
    if (!storedHash) {
      this.logger.warn(
        `Badge ${badgeId} has no stored hash (created before Story 6.5)`,
      );
      return {
        integrityVerified: false,
        storedHash: null,
        computedHash,
        tampered: false, // Can't determine tampering without baseline
      };
    }

    const integrityVerified = computedHash === storedHash;

    if (!integrityVerified) {
      this.logger.error(
        `ðŸ”´ INTEGRITY VIOLATION: Badge ${badgeId} assertion hash mismatch!\n` +
          `  Stored:   ${storedHash}\n` +
          `  Computed: ${computedHash}\n` +
          `  This indicates potential data tampering.`,
      );
    }

    return {
      integrityVerified,
      storedHash,
      computedHash,
      tampered: !integrityVerified,
    };
  }
}
